import { supabase } from '@/lib/supabase';
import { Database, Profile } from '@/types/database';
import { makeRedirectUri } from 'expo-auth-session';
import * as Google from 'expo-auth-session/providers/google';
import * as WebBrowser from 'expo-web-browser';
import { jwtDecode } from 'jwt-decode';

WebBrowser.maybeCompleteAuthSession();

const APP_SCHEME = 'lms';

type GoogleSigninModule = {
  GoogleSignin: {
    configure: (options: { webClientId: string }) => void;
    hasPlayServices?: () => Promise<void>;
    signIn: () => Promise<any>;
  };
  statusCodes?: Record<string, string>;
};

let googleSigninConfigured = false;

async function loadGoogleSigninModule(): Promise<GoogleSigninModule | null> {
  try {
    const mod = (await import('@react-native-google-signin/google-signin')) as unknown as GoogleSigninModule;
    return mod;
  } catch {
    return null;
  }
}

function getJwtNonceClaim(idToken: string): string | undefined {
  try {
    const payload = jwtDecode<{ nonce?: unknown }>(idToken);
    return typeof payload?.nonce === 'string' ? payload.nonce : undefined;
  } catch {
    return undefined;
  }
}

function looksLikeJwt(token: string): boolean {
  const parts = token.split('.');
  return parts.length === 3 && parts[0].length > 0 && parts[1].length > 0;
}

export interface AuthResponse {
  success: boolean;
  profile?: Profile;
  error?: string;
}

type ProfileUpdate = Database['public']['Tables']['profiles']['Update'];
type ProfileInsert = Database['public']['Tables']['profiles']['Insert'];

type AuthUserLike = {
  id: string;
  email?: string | null;
  user_metadata?: any;
};

function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function ensureProfileForUser(user: AuthUserLike): Promise<AuthResponse> {
  // Goal: return a profile even if the DB trigger is slow/missing.
  // Strategy: poll for existence; if missing, try one upsert; keep polling.

  const maxAttempts = 12; // ~10s total with backoff
  let didUpsert = false;

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const { data: profile, error: profileError } = await (supabase
      .from('profiles') as any)
      .select('*')
      .eq('user_id', user.id)
      .maybeSingle();

    if (profile) {
      return { success: true, profile };
    }

    // If RLS/network/etc prevents reading, fail fast with the real error.
    if (profileError) {
      return { success: false, error: profileError.message };
    }

    // Not found: on first pass, attempt to create/upsert a minimal profile.
    if (!didUpsert) {
      didUpsert = true;
      const newProfileData: ProfileInsert = {
        user_id: user.id,
        email: user.email || '',
        full_name: user.user_metadata?.full_name || user.user_metadata?.name || '',
        role: 'user',
      };

      const { error: upsertError } = await (supabase
        .from('profiles') as any)
        .upsert(newProfileData, { onConflict: 'user_id' });

      // If insert is blocked by RLS, the next loop would also never find it.
      // Return this error directly so it’s actionable.
      if (upsertError) {
        return { success: false, error: upsertError.message };
      }
    }

    // Backoff: 500ms, 700ms, 900ms, ... up to 1500ms
    const delay = Math.min(500 + attempt * 200, 1500);
    await sleep(delay);
  }

  return {
    success: false,
    error:
      'Profile creation timed out. Your account may have been created but the profile row is missing/blocked. Please try again, or check Supabase profiles trigger + RLS policies.',
  };
}

/**
 * Sign in with email and password
 */
export async function signInWithEmail(
  email: string,
  password: string
): Promise<AuthResponse> {
  try {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });

    if (error) {
      return { success: false, error: error.message };
    }

    if (!data.user) {
      return { success: false, error: 'No user data returned' };
    }

    // Ensure subsequent RLS queries are authenticated.
    if (data.session) {
      await supabase.auth.setSession({
        access_token: data.session.access_token,
        refresh_token: data.session.refresh_token,
      });
    }

    return await ensureProfileForUser(data.user as any);
  } catch (error: any) {
    return { success: false, error: error.message || 'Login failed' };
  }
}

/**
 * Sign up with email and password
 */
export async function signUpWithEmail(
  email: string,
  password: string,
  fullName?: string,
  employeeId?: string
): Promise<AuthResponse> {
  try {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: {
          full_name: fullName,
          employee_id: employeeId,
        },
      },
    });

    if (error) {
      return { success: false, error: error.message };
    }

    if (!data.user) {
      return { success: false, error: 'No user data returned' };
    }

    return await ensureProfileForUser(data.user as any);
  } catch (error: any) {
    return { success: false, error: error.message || 'Sign up failed' };
  }
}

/**
 * Sign out current user
 */
export async function signOut(): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase.auth.signOut();
    if (error) {
      return { success: false, error: error.message };
    }
    return { success: true };
  } catch (error: any) {
    return { success: false, error: error.message || 'Sign out failed' };
  }
}

/**
 * Get current session
 */
export async function getCurrentSession() {
  try {
    const { data, error } = await supabase.auth.getSession();
    if (error) throw error;
    return data.session;
  } catch (error) {
    console.error('Get session error:', error);
    return null;
  }
}

/**
 * Get current user profile
 */
export async function getCurrentProfile(): Promise<Profile | null> {
  try {
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) return null;

    const { data: profile, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('user_id', user.id)
      .single();

    if (error) {
      console.error('Get profile error:', error);
      return null;
    }

    return profile;
  } catch (error) {
    console.error('Get current profile error:', error);
    return null;
  }
}

/**
 * Update user profile
 */
export async function updateProfile(
  userId: string,
  updates: ProfileUpdate
): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await (supabase
      .from('profiles') as any)
      .update(updates)
      .eq('user_id', userId);

    if (error) {
      return { success: false, error: error.message };
    }

    return { success: true };
  } catch (error: any) {
    return { success: false, error: error.message || 'Update failed' };
  }
}

/**
 * Setup Google OAuth hook
 */
export function useGoogleAuth() {
  // Validate Google Client ID is configured
  const clientId = process.env.EXPO_PUBLIC_GOOGLE_CLIENT_ID;

  if (!clientId || clientId === 'your_google_client_id_here') {
    console.warn('⚠️  EXPO_PUBLIC_GOOGLE_CLIENT_ID is not configured properly!');
    console.warn('Please set it in your .env file or environment variables.');
    console.warn('Get your Client ID from: https://console.cloud.google.com/apis/credentials');
  }

  const [request, response, promptAsync] = Google.useAuthRequest({
    iosClientId: clientId,
    androidClientId: clientId,
    webClientId: clientId,
    scopes: ['openid', 'email', 'profile'],
    responseType: 'id_token',
    redirectUri: makeRedirectUri({
      scheme: APP_SCHEME,
      path: 'auth/callback'
    }),
  });

  return { request, response, promptAsync };
}

/**
 * Sign in with Google OAuth using ID token from expo-auth-session
 */
export async function signInWithGoogle(
  idToken: string,
  nonce?: string
): Promise<AuthResponse> {
  try {
    if (!looksLikeJwt(idToken)) {
      return { success: false, error: 'Invalid Google idToken (not a JWT). Check Google Sign-In configuration.' };
    }

    // If the id_token contains a nonce claim, Supabase expects a matching nonce.
    // To avoid mismatch errors across different clients, we derive the nonce directly
    // from the token when present and only pass it in that case.
    const tokenNonce = getJwtNonceClaim(idToken);
    const nonceToSend = tokenNonce ? tokenNonce : undefined;

    // Use signInWithIdToken without nonce parameter
    // Supabase will validate the id_token directly
    const { data, error } = await supabase.auth.signInWithIdToken({
      provider: 'google',
      token: idToken,
      nonce: nonceToSend,
    });

    if (error) {
      return { success: false, error: error.message };
    }

    if (!data.user) {
      return { success: false, error: 'No user data returned' };
    }

    // Ensure subsequent RLS queries are authenticated.
    if (data.session) {
      await supabase.auth.setSession({
        access_token: data.session.access_token,
        refresh_token: data.session.refresh_token,
      });
    }

    return await ensureProfileForUser(data.user as any);
  } catch (error: any) {
    return { success: false, error: error.message || 'Google sign in failed' };
  }
}

/**
 * Native Google sign-in for Expo React Native (recommended by Supabase docs).
 * Requires a Development Build / custom dev client (not Expo Go).
 */
export async function signInWithGoogleNative(): Promise<AuthResponse> {
  const mod = await loadGoogleSigninModule();
  if (!mod?.GoogleSignin) {
    return {
      success: false,
      error:
        'Google Sign-In native module not available. Use a Development Build / EAS build (not Expo Go), or disable nonce check in Supabase Google provider as a last resort.',
    };
  }

  const webClientId =
    process.env.EXPO_PUBLIC_GOOGLE_WEB_CLIENT_ID || process.env.EXPO_PUBLIC_GOOGLE_CLIENT_ID;

  if (!webClientId) {
    return {
      success: false,
      error: 'Missing EXPO_PUBLIC_GOOGLE_WEB_CLIENT_ID (or EXPO_PUBLIC_GOOGLE_CLIENT_ID).',
    };
  }

  try {
    if (!googleSigninConfigured) {
      mod.GoogleSignin.configure({ webClientId });
      googleSigninConfigured = true;
    }

    // Android only (safe to call if present)
    await mod.GoogleSignin.hasPlayServices?.();

    const response = await mod.GoogleSignin.signIn();

    // Support multiple response shapes across versions
    const idToken = response?.data?.idToken || response?.idToken || response?.user?.idToken;
    if (!idToken) {
      return { success: false, error: 'Google Sign-In did not return idToken.' };
    }

    // Reuse existing Supabase + profile logic
    return await signInWithGoogle(idToken);
  } catch (error: any) {
    // Keep message concise for UI
    return { success: false, error: error?.message || 'Google native sign in failed' };
  }
}

/**
 * Reset password
 */
export async function resetPassword(
  email: string
): Promise<{ success: boolean; error?: string }> {
  try {
    const { error } = await supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${APP_SCHEME}://reset-password`,
    });

    if (error) {
      return { success: false, error: error.message };
    }

    return { success: true };
  } catch (error: any) {
    return { success: false, error: error.message || 'Password reset failed' };
  }
}
